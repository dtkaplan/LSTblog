{
  "hash": "1bc0ba167055efa8f8ccf81e0d48ce9e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Writing assignments with Web-R and `{devoirs}`\"\nauthor: \"Daniel Kaplan\"\ndate: \"2024-06-04\"\ncategories: [LSTbook, computing, instructors]\ncrossref:\n  custom:\n    - key: qst\n      kind: float\n      reference-prefix: \"Question\"\n# Enable webR\nwebr:\n  channel-type: 'automatic'\n  packages: ['ggplot2', 'dplyr', 'LSTbook', 'ggformula', 'mosaicData', 'moderndive', 'palmerpenguins', 'babynames', 'knitr', 'rmarkdown', 'stringdist', 'mosaicData' ]\nfilters:\n  - webr\n---\n\n\n\n\nThe Quarto/webR system enables instructors to write .qmd -> HTML documents that contain interactive computing chunks that run in the student's browser, hence avoiding the need to support a web-service version of R such as `posit.cloud` or `shinyapps.io`.  \n\nHere's an example of such a chunk:\n\n```{webr-r}\nggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +\n  geom_point()\n```\n\nFor an instructor, one potential application of this run-R-in-the-browser capability is for home-work style assignments.\n\nThe lightweight `{devoirs}` package [\"*devoirs*\" is French for \"homework.\"]{.aside} lets you instrument the quarto->HTML file so that student work in Web-R can easily be submitted. \n\n`{devoirs}` also provides responsive \"multiple-choice\" and essay questions formats that are straightforward to author and for which student answers can be collected. (The multiple-choice and essay formats are independent of Web-R and can be used in non-Web-R documents as well.)\n\n## Structure of the Quarto source document\n\n`{devoirs}` operates within an ordinary Quarto -> HTML file. Making use of `{devoirs}` involves placing three simple structured elements at the appropriate positions in the file.\n\n1. A chunk near the start of the document to load the `{devoirs}` library:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nlibrary(devoirs)\n```\n````\n:::\n\n\n2. A chunk (typically at near the start of the document) that provides the facility to collect the student answers in a format that can be pasted into whatever web-based collection facility you use. This example uses a Google Form, but instructors will want to create their own Google Form or other link for uploading homework answers.\n\nIn addition to specifying an ID for the document and the the target URL, the chunk includes a call to `devoirs_start()`. This will create a small bit of HTML with a button, a link, and a display element reading, \"No answers yet collected.\"\n     \n\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ntargetURL <- \"https://docs.google.com/forms/d/e/1FAIpQLSevJgyHTRHm6_HVQqrYMd8wjMYifPknPLXtpVTunlWlO7RbMw/viewform?usp=pp_url\"\n\ndevoirs_start(documentID = \"June 4 blog post\",\n              collectURL = targetURL) \n```\n````\n\n<span id=\"devoirs-docID\" style=\"display: none;\">June 4 blog post</span>\n<button onclick=\"devoirsSubmit()\">Collect your answers</button> then paste them <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSevJgyHTRHm6_HVQqrYMd8wjMYifPknPLXtpVTunlWlO7RbMw/viewform?usp=pp_url\" target=\"popup\">here</a>.\n<div id=\"devoirs_summary\">No answers yet collected</div>\n\n\n \n\nA student wishing to submit answers will press the button. This will create a JSON string with the student's answers and copy it onto the computer clipboard. Then the student follows the link and pastes in the JSON string from the clipboard.\n\n3. At the end of the document (after any `{devoirs}` questions) a closing R chunk that provides the necessary javascript functionality to power the answer collection. \n\n\n::: {.cell}\n\n:::\n\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ndevoirs_end()\n```\n````\n\n::: {.cell}\n\n:::\n\n\nPlace your questions and WebR chunks before the `devoirs_end()` marker. \n\n## Multiple-choice question: Example\n\nEach multiple-choice question is placed in a chunk with the `mcq` engine. To be more precise, it is the answers choices that go in the `mcq` chunk. The question prompt goes before that chunk.\n\nQuestion prompt: What color is the blue moon? \n\nMarkup to provide three choices:\n\n     ``{mcq}\n     #| label: blue-moon\n     #| inline: true\n     #| show_hints: true\n     1. blue [hint: It's not blue!]\n     2. red $\\sqrt{3}$\n     3. moon colored [correct]\n     ```\n     \nOutput from the `mcq` chunk:\n\n\n::: {.cell inline='true' show_hints='true'}\n<input type=\"radio\" class=\"devoirs-mcq\" value=\"blue\" id=\"blue-moon-1\" truth=\"false\" name=\"blue-moon\" hint=\"It&#39;s not blue!\" show_hints=\"TRUE\"/>\nblue\n     \n<input type=\"radio\" class=\"devoirs-mcq\" value=\"red $\\sqrt{3}$\" id=\"blue-moon-2\" truth=\"false\" name=\"blue-moon\" hint=\"Better luck next time.\" show_hints=\"TRUE\"/>\nred $\\sqrt{3}$\n     \n<input type=\"radio\" class=\"devoirs-mcq\" value=\"moon colored\" id=\"blue-moon-3\" truth=\"correct\" name=\"blue-moon\" hint=\"Admittedly silly, but ...\" show_hints=\"TRUE\"/>\nmoon colored\n     \n<input type=\"radio\" class=\"devoirs-mcq\" name=\"blue-moon\" id=\"blue-moon.default\" style=\"display: none;\" truth=\"skipped\" checked=\"\"/>\n<div>\n  <small style=\"color: grey;\" id=\"blue-moon-hintarea\">question id: blue-moon</small>\n</div>\n:::\n\n\nThere are two types of options used in the `mcq` chunk:\n\n1. YAML-formatted options as with ordinary R chunks in quarto. In the above example, there are three such YAML options:\n\n    i. `label:` which specifies the unique ID to be used for this multiple-choice question. Such an ID is required for every multiple-choice question.\n    \n    ii. `inline:` which causes the choices to be laid out horizontally. Leaving this option out, or setting it to `false` will put each choice on its own line.\n    \n    iii. `show_hints:` which, if `true` will display the hint associated with each individual choice. By default, the hints are set as nice ways of saying \"no\" for the choices not marked as correct, and something encouraging for the correct choice(s).\n    \n2. Options to be provided for the individual multiple-choice items within the `mcq` chunk.  \n\nFollowing the YAML, each choice item is placed on its own line. The line has three components:\n\n1. An index followed by a period. This is not part of the choice, but will be reported when the student answers are collected.\n2. The text for the choice. This can include LaTeX math markup.\n3. (Optionally) A pair of square braces containing information for that particular choice. \n    a. A choice which is to be marked as correct will have the word `correct` as the lead-off item. \n    b. Other options---as of this writing, there is only a custom `hint:` option---in a simple YAML-style syntax. If no hint is provided, one will be generated at random taking into account whether the choice is `[correct]` or not.\n\n## Essay question: Example\n\nEssay *answer fields* are generated with the `devoirs_text()` function. The argument is a unique ID to identify the field when the answers are collected and submitted. \n\n\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ndevoirs_text(\"Essay-1\")\n```\n````\n\n```{=html}\n<textarea id=\"Essay-1\" name=\"Essay-1\" class=\"devoirs-text\" rows=\"4\" cols=\"50\" placeholder=\"Type here for question ID Essay-1\"></textarea>\n<div style=\"color: grey;\">\n<small>question id: Essay-1</small>\n</div>\n```\n\n\nNote that this is a regular `{r}` chunk, as distinct from the `{mcq}` engine used in multiple-choice questions. \n\nTypically, an author will place a prompt for the essay *before* the `devoirs_text()` chunk, using ordinary markdown syntax. I have not done that here.\n\n## WebR chunks\n\nEvery WebR chunk is automatically included in the answer collection.\n\n## Action of collecting answers\n\n[Before reading the following, you may want to select one of the choices in the above multiple-choice question and write some little thing in the essay answer field.]\n\nWhen the student reaches the point where she wants to submit her answers, she presses the \"Collect your answers\" button near the top of the document. This has two distinct consequences.\n\na. The \"No answers yet collected\" display changes into a summary of the answers provided by the student.\n\nb. A JSON-formatted string is copied to the clipboard.\n\nPressing the button sets things up for the actual submission. The student will follow the \"then paste them [here]()\" link and paste the JSON-formatted string at the URL that's linked to. Note: The student must complete the pasting of the JSON for her answers to be submitted.\n\nFor the answers that I provided when exercising this functionality, the JSON string was:\n\n```\n{\"docid\":\"index.rmarkdown\",\"MC\":[{\"itemid\":\"blue-moon-1\",\"truth\":\"false\",\"start\":\"blue\"}],\"Essays\":[{\"itemid\":\"Essay-1\",\"contents\":\"When in the course of human events ...\"}],\"WebR\":[{\"chunk_id\":0,\"code\":\"ggplot(mtcars, aes(x = wt, y = mpg, color = cyl)) +\\n  geom_point()\"}]}\n```\n\nYou can easily see my answers. Naturally, if you try this on your own you will see your own answers. For the WebR chunks, the answer reported will be the *code* in the chunk at the time \"Collect your answers\" was pressed.\n\n## Processing the submitted answers\n\nThis will depend on how your target URL works. In this document, the target is a Google Form and the spreadsheet is at [] (I have set up my Google Form so that the spreadsheet can be read by following this [link](https://docs.google.com/spreadsheets/d/1w4HsxZaM3m40aQArBrkjFg08LXQ6ZPQ174IJuEL1mIs/edit?usp=sharing). Typically, an instructor would limit read access to the spreadsheet.) In such a situation, the processing will be:\n\n1. Go to the spreadsheet attached to the Google form and download it. Then read it into an R session as a data frame. Each student submission will have one JSON string containing the answer information.\n\n2. Use R data wrangling to filter the spreadsheet for the document ID you want to see the answers for.\n\n3. Collate the student answers to assign a score. \n\nIt's planned to provide as part of the `{devoirs}` package some resources for such wrangling and collating. But these don't yet exist.\n\n\n\n\n\n## Question IDs\n\n\n## At the end of the document\n\nThis is where the `devoirs_end()` chunk should be placed.\n\n\n````{.cell-code}\n```{{r}}\n#| results: asis\ndevoirs_end()\n```\n````\n\n```{=html}\n<script type='text/javascript'>\n console.log(\"In devoirs.js\")\n\nfunction devoirsCollectEssays() {\n  var essay_answers = [];\n  var items = document.getElementsByClassName(\"devoirs-text\");\n  for (i = 0; i < items.length; i++) {\n    //console.log(\"text entry\" + i + \"being handled\");\n    essay_answers[i] = {itemid: items[i].id, contents: items[i].value}\n  }\n\n  return essay_answers;\n}\n\nfunction devoirsGetDocID() {\n  return document.getElementById(\"devoirs-docID\").innerHTML\n}\n\nfunction devoirsCollectMC() {\n    let mc_answers = [] // Hold the information\n    var ele = document.getElementsByClassName(\"devoirs-mcq\");\n    var count = 0;\n    for (i = 0; i < ele.length; i++) {\n        if (ele[i].checked) {\n          //console.log(\"Entering conditional.\");\n          let checked_one = ele[i];\n          mc_answers[count++] = {itemid: checked_one.id, truth: checked_one.getAttribute(\"truth\"), start: checked_one.value};\n        }\n    }\n    return mc_answers;\n}\n\nconsole.log(\"About to define WebR\")\n\nfunction devoirsCollectWebR() {\n  var chunk_contents = []; // placeholder for collecting webr items\n  if (typeof qwebrCellDetails == \"undefined\") {\n    // There aren't any webr chunks\n    return chunk_contents;\n  }\n  var chunks = qwebrCellDetails;\n  for (i = 0; i < chunks.length; i++) {\n    chunk_contents[i] = {chunk_id: i, code: chunks[i].code};\n  }\n\n  return chunk_contents;\n}\n\nconsole.log(\"About to define devoirsSubmit\")\n\nfunction devoirsSubmit() {\n  items = {docid: devoirsGetDocID(), MC: devoirsCollectMC(), Essays: devoirsCollectEssays(), WebR: devoirsCollectWebR()}\n\n  navigator.clipboard.writeText(JSON.stringify(items));\n\n  // summarize what's being collected\n  var my_summary = \"A summary of your collected answers: Fixed choice: \" + items.MC.length + \" Essays: \" + items.Essays.length + \" WebR chunks: \" + items.WebR.length\n\n  document.getElementById(\"devoirs_summary\").innerHTML = my_summary;\n}\n\nconsole.log(\"Read devoirsSubmit()\")\n\n// Hint handling in Multiple choice\n\n// Still have to add an on/off switch from options\n\nfunction devoirs_setup_hintarea() {\n  answers = document.getElementsByClassName(\"devoirs-mcq\")\n  for (i=0; i<answers.length; i++) answers[i].addEventListener('click', function(e){document.getElementById(e.target.name + \"-hintarea\").innerHTML = e.target.getAttribute(\"hint\")})\n}\n\n window.addEventListener(\"load\", function() {\n  answers = document.getElementsByClassName(\"devoirs-mcq\")\n  for (i=0; i<answers.length; i++) {\n    if (answers[i].getAttribute(\"show_hints\") == \"TRUE\") {\n      answers[i].addEventListener('click', function(e){document.getElementById(e.target.name + \"-hintarea\").innerHTML = e.target.getAttribute(\"hint\")})\n    }\n  }\n})\n\nconsole.log(\"Added hint summary.\") \n</script>\n\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}